// null 체크
const initialState: WeatherType | null = null;

const weatherSlice = createSlice({
name: 'weather',
initialState,
reducers: {},
extraReducers: (builder) => {
builder.addCase(fetchWeather.fulfilled, (state, action) => {
state = action.payload;
});
},
});

export default weatherSlice.reducer;

[문제]
여기서 '{ name: string; main: { temp: number; }; weather: { main: string; description: string; icon: string; }[]; }' 형식은 'null' 형식에 할당할 수 없습니다.ts(2322) 일 때 문제 해결법

[해설]
초기 상태 값이 null로 설정되어 있지만, 해당 상태에 null이 아닌 다른 형식의 데이터를 할당하려 할 때 발생합니다.

이를 해결하기 위해서는 초기 상태의 타입을 nullable하게 설정해야 합니다. WeatherType | null 타입으로 초기 상태를 설정했기 때문에, state의 타입도 이와 동일하게 설정되어야 합니다. 하지만, createSlice에서 state는 readonly이므로, 직접 state에 값을 할당할 수 없습니다. 따라서 state의 내용을 변경하는 방법으로 해결해야 합니다.

아래의 코드처럼 extraReducers 부분을 수정하여 에러를 해결할 수 있습니다.

[해결]
const weatherSlice = createSlice({
name: 'weather',
initialState,
reducers: {},
extraReducers: (builder) => {
builder.addCase(fetchWeather.fulfilled, (state, action) => {
// `state`는 readonly이므로, 내용을 변경하는 방식으로 값을 설정
return action.payload;
});
},
});

[문제 또 발생]
오류 메시지를 보면, createSlice에서 extraReducers의 addCase에 대한 오버로드 매칭 오류가 발생하고 있습니다. 이는 리듀서의 상태 타입과 액션의 페이로드 타입이 일치하지 않을 때 발생할 수 있습니다.

주어진 코드에서 state는 초기에 null로 설정되어 있고, WeatherType | null 타입을 가지므로, 이 state에 대한 변경을 처리할 때 상태를 올바르게 설정해야 합니다.

이를 위해 다음과 같이 코드를 수정할 수 있습니다:

[해결]
const weatherSlice = createSlice({
name: 'weather',
initialState,
reducers: {},
extraReducers: (builder) => {
builder.addCase(fetchWeather.fulfilled, (state, action) => {
// state를 직접 변경할 수 없으므로, Object.assign을 사용하여 상태 값을 변경합니다.
return Object.assign({}, state, action.payload);
});
},
});
